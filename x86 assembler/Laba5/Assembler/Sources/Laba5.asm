model  SMALL
stack  100h
dataseg

	Ask1  db 0Ah,0Dh,'Enter first:$'; приглашение на ввод первого числа
	Ask2  db 0Ah,0Dh,'Enter second:$'; приглашение на ввод второго числа ;
	Buf1  db 11
	Len1  db ?						; длина 1 строки
	Opnd1  db 12 dup( ? )			; буфер 1 числа
	Buf2  db 11
	Len2  db ?						; длина 2 строки
	Opnd2  db 12 dup( ? ) 			; буфер 2 числа
	ResT  db 0Ah,0Dh,'Result: '		; приглашение на вывод результата 
	Res  db 12 dup(' '),'$'			; буфер результата
	AskCont db 0Ah,0Dh
	db 'Exit - Esc, Next - all '
	db '$'
	
codeseg
startupcode
	push  DS
	pop  ES  						; ES <- DS

BEGIN:

;Ввод первого слагаемого
B1:  
	lea  DX, Ask1 				; в DX занести адрес строки
	mov  AH, 09h 				; в АН занести номер функции (вывод)
	int  21h  					; вызов прерывания 
	
	lea  DX, Buf1 				; в DX занести адрес строки
	mov  AH, 0Ah 				; в АН занести номер функции (ввод)
	int  21h 					; вызов прерывания
	
	cmp  Len1, 0 				; сравниваем длину строки с нулем
	je  B1 						; если равен нулю, то вводим заново
   
;проверка 0-9 и очистка старш.тетрады
	lea  BX, Opnd1
	xor  CX, CX 				; обнулить регистр CX
	mov  CL, Len1 				; в СL занести длину строки
	xor  SI, SI  				; обнулить регистр SI    
  
T1:  
	mov  AL, [BX][SI]
	cmp  AL, '0' 				; сравнить с кодом нуля
	jb  B1  					; ошибка  ; если ниже, ошибка
	cmp  AL, '9'  				; сравнить с кодом девятки
	ja  B1  					; ошибка  ; если выше, ошибка
	and  AL, 0Fh 				; обнулить старшую тетраду (АL & 0000 1111)
	mov  [BX][SI], AL 			; занести результат в массив
	inc  SI 					; перейти к следующему элементу
	loop  T1 					; проверка на конец цикла и переход на метку
  
;прижать к правому краю
	mov  CL, Len1 				; в CL занести длину строки
	cmp  CL, 10 				; сравнить СL с 10
	je  E1 						; если равно, то перейти на метку
	mov  DI, 9 					; в DI занести смещение (адрес конца строки)
	mov  SI, CX   				; в SI занести смещение (адрес первого разряда + 1)
	dec  SI  					; уменьшить SI на единицу  
P1:  
	mov  AL, [BX][SI] 			; в АL занести элемент массива
	mov  [BX][DI], AL		 	; поместить AL в правую часть массива
	dec  DI						; уменьшить DI на единицу
	dec  SI  					; уменьшить SI на единицу
	loop  P1 					; проверить на конец цикла и перейти по метке
  
;обнулить лишнее
	xor  DI, DI 				; обнулить регистр DI
	mov  CL, 10 				; занести в регистр СL значение 10
	sub  CL, Len1  				; отнять от CL длину строки
N1:  
	mov  byte ptr [BX][DI], 0	; заменить на нуль
	inc  DI						; увеличить DI на единицу
	loop  N1 					; проверить на конец цикла и перейти по метке
E1:

;Ввод второго слагаемого
B2: 
	 lea  DX, Ask2 			 	; в DX занести адрес строки
	 mov  AH, 09h 				; в АН занести номер функции (вывод)
	 int  21h 					; вызов прерывания
	 lea  DX, Buf2  			; в DX занести адрес строки
	 mov  AH, 0Ah				; в АН занести номер функции (ввод)
	 int  21h 					; вызов прерывания
	 cmp  Len2, 0 				; сравниваем длину строки с нулем
	 je  B2						; если равен нулю, то вводим заново
  
;проверка 0-9 и очистка старш.тетрады
	  lea  BX, Opnd2
	  xor  CX, CX 				; обнулить регистр CX
	  mov  CL, Len2 			; в СL занести длину строки
	  xor  SI, SI				; обнулить регистр SI
  
T2: 
	 mov  AL, [BX][SI]
	  cmp  AL, '0'				; сравнить с кодом нуля
	  jb  B2  					; ошибка если < 0
	  cmp  AL, '9'  			; сравнить с кодом девятки
	  ja  B2  					; ошибка если > 0
	  and  AL, 0Fh				; обнулить старшую тетраду (& 0000 1111)
	  mov  [BX][SI], AL			; занести результат в массив
	  inc  SI					; перейти к следующему элементу
	  loop  T2					; проверка на конец цикла и переход на метку
  
;прижать к правому краю
	  mov  CL, Len2				; в CL занести длину строки
	  cmp  CL, 10 				; сравнить СL с 10
	  je  E2 					; если равно, то перейти на метку 
	  mov  DI, 9				; в DI занести смещение (адрес конца строки)
	  mov  SI, CX				; в SI занести смещение (адрес первого разряда + 1)
	  dec  SI 					; уменьшить SI на единицу
  
P2: 
	 mov  AL, [BX][SI]			; в АL занести элемент массива
	  mov  [BX][DI], AL			; поместить AL в правую часть массива
	  dec  DI					; уменьшить DI на единицу
	  dec  SI					; уменьшить SI на единицу
	  loop  P2 					; проверить на конец цикла и перейти по метке
	  
;обнулить лишнее
	  xor  DI, DI				; обнулить регистр DI
	  mov  CL, 10 				; занести в регистр СL значение 10
	  sub  CL, Len2 			; отнять от CL длину строки
N2: 
	 mov  byte ptr [BX][DI], 0	; заменить на нуль
	 inc  DI 					; увеличить DI на единицу
	 loop  N2 					; проверить на конец цикла и перейти по метке
E2:

;Вычитание
	xor CX, CX 					; Очищаем регистр CX
	mov  CX, 10
	lea SI, Opnd1+9 			; Адрес первого операнда
	lea DI, Opnd2+9 			; Адрес второго операнда
	lea BX, Res+10  			; Адрес результата

A1:     
	mov     AL, [SI] 
	sbb     AL, [DI] 
	aas 
	mov     [BX], AL 
	dec     SI 
	dec     DI 
	dec     BX 
	loop    A1 
	jc _NEG
	jmp _POS
_NEG:
	mov CX, 10
	clc
	lea BX, Res+10
NEG_loop:
	mov AL, 10h;
	sbb AL, [BX]
	aas
	mov [BX], AL
	dec BX
	loop NEG_loop
	mov byte ptr [BX], 2Dh
	inc BX
	mov CX, 10
	jmp A2
_POS:
;Преобразование результата в ASCII 
	mov CX, 11 
A2:     
	or byte ptr [BX], 30h 
	inc  BX 
	loop  A2 
	;Вывод результата 
	lea     DX, ResT 
	mov     AH, 09h 
	int     21h 
	;Запрос на продолжение работы 
	lea     DX, AskCont 
	mov     AH, 09h 
	int     21h 
	mov     AH, 08h 
	int     21h 
	cmp     AL, 27  
	;ESC 
	je      QUIT 
	jmp     BEGIN ;Конец работы 
QUIT:   
exitcode  0 
end